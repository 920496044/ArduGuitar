/* timeout is bad!
 * this version uses a boolean to prime the pump!
 */

#include <outQueue.h>
#include <ArduCom.h>

/// Global Variables
int incomingMsgSizeSerial = ARDUCOM_MSGSIZE, 
    currentCharCountSerial = 0;   // how many chars we've read on Serial or Serial1

char outgoingBuffer[ARDUCOM_MSGSIZE];

ArduComMaster *c;

///////////////////////////////////////////////////////////////////////////
/////////////  Terminal Input and equeueing       /////////////////////////
///////////////////////////////////////////////////////////////////////////
void processSerialMonitorIncoming() {
  // this is a part of the test suite, not of the ArduCom class 
  // If we have already read a whole atom, then enqueue it for sending, and reset char count
  // or, if we have something to read, add it to the current underwork atom
  if (currentCharCountSerial == incomingMsgSizeSerial){
    c->enqueueMsg(outgoingBuffer);
    ArduCom::msg("Enqueued:" ,outgoingBuffer,c->msgSize);
    currentCharCountSerial = 0;
  }
  else if (Serial.available()>0){
    outgoingBuffer[currentCharCountSerial++] = Serial.read();
  }
}

///////////////////////////////////////////////////////////////////////////
///////////////////  Serial1 Reading and writing  /////////////////////////
///////////////////////////////////////////////////////////////////////////

boolean procReply(char *reply, int replySize){
  // if it starts with e, then not ok!
  // otherwise, if any of the chars do not match the last sent, i.e. the top of the queue, 
  // then not ok.
  if(reply[0] == 'e'){
    return false;
  }
  boolean ret = true;
  char *sent = c->peekQ();
  for (int i=1; i< c->responseSize;i++){
    if (sent[i-1] != reply[i]){
      ret = false;
      break;
    }
  }
  return ret;
}

///////////////////////////////////////////////////////////////////////////
///////////////////       Std Functions     ///////////////////////////////
///////////////////////////////////////////////////////////////////////////
void setup(){
  Serial.begin(115200); // for input from Serial Monitor
  while(!Serial);
  delay(5000);           // to give the human time to start the Serial Monitor
  c = new ArduComMaster(&Serial1,&procReply,ARDUCOM_MSGSIZE);
  c->doInit();
  Serial.println("Ready!");
}
    
void loop(){
  // read and process anything from the Serial Monitor; 
  processSerialMonitorIncoming();
  // step the comms loop
  c->stepLoop();
}

